// Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
//
// SPDX-License-Identifier: (Apache-2.0 AND BSD-3-Clause)

//! Helper structs for working with VirtQueue rings.
//!
//! The virtqueue rings are dynamically sized types since they contain an array that has the
//! size of the virtqueue, which can only be determined at runtime. For example this is the
//! definition of the structure representing the virtqueue available ring:
//!
//! ```C
//! struct virtq_avail {
//!     le16 flags;
//!     le16 idx;
//!     le16 ring[ /* Queue Size */ ];
//!     le16 used_event; /* Only if VIRTIO_F_EVENT_IDX */
//! };
//! ```
//!
//! Because of this constraint, we can't represent them with a simple statically-sized rust struct.
//! However, we can leverage some of the properties of the rust structures in order to make it
//! easier to work with these types.
//!
//! TODO: check if this can be implemented better after FixedSizeArray in CoerceUnsized
//! become stable

use memory_model::{GuestAddress, GuestMemory, GuestMemoryError};
use std::mem::size_of;
use std::ops::{Index, IndexMut};

#[derive(Debug)]
pub enum Error {
    // An error generated by the GuestMemory module
    GuestMemoryError(GuestMemoryError),
    // the structure doesn't fit in the provided GuestMemory
    InsufficientMemory,
}

/// Trait denoting that a rust struct is a Virtq ring mirror structure.
///
/// We can make it easier to work with virtqueue rings by defining mirror structures that respect
/// the following properties:
/// * they are PODs
/// * they mirror all the members of the original structure found before the dynamically sized
///   array. These members will be easily accessible as regular members of a structure.
/// * instead of the dynamically sized array, they contain a zero sized slice of type `Element`.
///   This affects the size of the mirror structure by including padding added to accommodate
///   the array. This way we ensure that we can find the array at the end of the mirror structure.
/// * `Element` is a POD.
/// * they don't contain anything after the zero sized slice. All the members of the original
///   structure found after the dynamically sized array can be handled by directly accessing
///   the memory.
///
/// For example, a mirror structure for `virtq_avail` would look like this:
///
/// ```rust
/// #[repr(C)]
/// pub struct VirtqAvail {
///     pub flags: u16,
///     pub idx: u16,
///     pub ring: [u16; 0],
/// }
/// ```
///
/// This trait is unsafe since there is no way to check that the implementor respects the
/// properties listed above. Violating these constraints may cause problems.
pub unsafe trait VirtqRingMirror {
    // The type of the ring elements.
    type Element;
}

#[derive(Debug)]
pub struct VirtqRingPtr<T: VirtqRingMirror> {
    ptr: *mut T,
    size: u16,
}

impl<T: VirtqRingMirror> VirtqRingPtr<T> {
    /// Create a new instance of RingStructPtr.
    pub fn new(addr: GuestAddress, mem: &GuestMemory, size: u16) -> Result<Self, Error> {
        // check if the VirtqRing would fit in the provided memory
        let virtq_ring_size = size_of::<T>() + size_of::<T::Element>() * size as usize;
        if mem.checked_offset(addr, virtq_ring_size - 1).is_none() {
            return Err(Error::InsufficientMemory);
        }

        let ptr = mem
            .get_host_address(addr)
            .map_err(Error::GuestMemoryError)?;

        Ok(Self {
            ptr: ptr as usize as *mut T,
            size,
        })
    }

    /// Normalize the specified index.
    fn norm_idx(&self, index: u16) -> u16 {
        index % self.size
    }

    /// Get a pointer to the beginning of the ring.
    fn ring_ptr(&self) -> *const T::Element {
        // `T` implements the `VirtqRingMirror` trait. This way we are sure to find the ring
        // right at the end of the `T` structure.
        unsafe { self.ptr.offset(1) as *const T::Element }
    }

    /// Get a mut pointer to the beginning of the ring.
    fn ring_ptr_mut(&mut self) -> *mut T::Element {
        // `T` implements the `VirtqRingMirror` trait. This way we are sure to find the ring
        // right at the end of the `T` structure.
        unsafe { self.ptr.offset(1) as *mut T::Element }
    }
}

impl<T: VirtqRingMirror> AsRef<T> for VirtqRingPtr<T> {
    /// Get a reference to the actual T instance.
    fn as_ref(&self) -> &T {
        unsafe { &*self.ptr }
    }
}

impl<T: VirtqRingMirror> AsMut<T> for VirtqRingPtr<T> {
    /// Get a mut reference to the actual T instance.
    fn as_mut(&mut self) -> &mut T {
        unsafe { &mut *self.ptr }
    }
}

impl<T: VirtqRingMirror> Index<u16> for VirtqRingPtr<T> {
    type Output = T::Element;

    /// Get a reference to the Ring element at the specified index.
    fn index(&self, index: u16) -> &Self::Output {
        let ptr = unsafe { self.ring_ptr().offset(self.norm_idx(index) as isize) };
        unsafe { &*ptr }
    }
}

impl<T: VirtqRingMirror> IndexMut<u16> for VirtqRingPtr<T> {
    /// Get a mut reference to the Ring element at the specified index.
    fn index_mut(&mut self, index: u16) -> &mut Self::Output {
        let ptr = unsafe { self.ring_ptr_mut().offset(self.norm_idx(index) as isize) };
        unsafe { &mut *ptr }
    }
}

#[cfg(test)]
pub mod tests {
    use crate::virtio::base::ring::{Error, VirtqRingMirror, VirtqRingPtr};
    use memory_model::{DataInit, GuestAddress, GuestMemory};

    const GUEST_ADDR: GuestAddress = GuestAddress(0);
    const RING_SIZE: usize = 10;
    const RING: [u64; RING_SIZE] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    #[repr(C)]
    #[derive(Copy, Clone)]
    struct MockVirtqRing {
        pub u16_member: u16,
        pub u32_member: u32,
        pub ring: [u64; RING_SIZE],
    }

    const MOCK_VIRTQ_RING: MockVirtqRing = MockVirtqRing {
        u16_member: 16,
        u32_member: 32,
        ring: RING,
    };

    #[repr(C)]
    #[derive(Copy, Clone, Debug)]
    struct MockVirtqRingMirror {
        pub u16_member: u16,
        pub u32_member: u32,
        pub ring: [u64; 0],
    }

    unsafe impl DataInit for MockVirtqRing {}

    unsafe impl VirtqRingMirror for MockVirtqRingMirror {
        type Element = u64;
    }

    #[test]
    fn test_new_virtq_ring_ptr_with_err() {
        let mem = GuestMemory::new(&[(GUEST_ADDR, std::mem::size_of::<MockVirtqRing>())]).unwrap();

        let maybe_mock_virtq_ring_ptr = VirtqRingPtr::<MockVirtqRingMirror>::new(
            GUEST_ADDR.unchecked_add(1),
            &mem,
            RING_SIZE as u16,
        );
        match maybe_mock_virtq_ring_ptr {
            Err(Error::InsufficientMemory) => {}
            other => {
                panic!("Expected InsufficientMemory. Found {:?}", other);
            }
        }
    }

    #[test]
    fn test_virtq_ring_ptr() {
        let mem = GuestMemory::new(&[(GUEST_ADDR, std::mem::size_of::<MockVirtqRing>())]).unwrap();
        assert!(mem.write_obj_at_addr(MOCK_VIRTQ_RING, GUEST_ADDR).is_ok());
        let mut mock_virtq_ring_ptr =
            VirtqRingPtr::<MockVirtqRingMirror>::new(GUEST_ADDR, &mem, RING_SIZE as u16).unwrap();

        // check that u16_member has been correctly read and is correctly updated
        assert_eq!(
            mock_virtq_ring_ptr.as_ref().u16_member,
            MOCK_VIRTQ_RING.u16_member
        );
        mock_virtq_ring_ptr.as_mut().u16_member += 1;
        assert_eq!(
            mock_virtq_ring_ptr.as_ref().u16_member,
            MOCK_VIRTQ_RING.u16_member + 1
        );

        // check that u32_member has been correctly read and is correctly updated
        assert_eq!(
            mock_virtq_ring_ptr.as_ref().u32_member,
            MOCK_VIRTQ_RING.u32_member
        );
        mock_virtq_ring_ptr.as_mut().u32_member += 1;
        assert_eq!(
            mock_virtq_ring_ptr.as_ref().u32_member,
            MOCK_VIRTQ_RING.u32_member + 1
        );

        // check that each member of the ring has been correctly read and is correctly updated
        for i in 0..RING_SIZE {
            assert_eq!(mock_virtq_ring_ptr[i as u16], MOCK_VIRTQ_RING.ring[i]);
            mock_virtq_ring_ptr[i as u16] += 1;
            assert_eq!(mock_virtq_ring_ptr[i as u16], MOCK_VIRTQ_RING.ring[i] + 1);
        }

        // check that norm_idx works correctly
        for i in RING_SIZE..RING_SIZE * 2 {
            assert_eq!(
                mock_virtq_ring_ptr[i as u16],
                MOCK_VIRTQ_RING.ring[i - RING_SIZE] + 1
            );
        }
    }
}
